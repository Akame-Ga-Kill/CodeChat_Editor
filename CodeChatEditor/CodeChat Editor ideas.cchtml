<h1>CodeChat Editor overview</h1>
<div>The CodeChat Editor should be a GUI-based programmer's word processor /
    Jupyter for software developers. This document records its overall design.
</div>
<h2>Vision</h2>
<div>
    <ul>
        <li>View source code as code blocks and doc blocks. Doc blocks are
            lines of source which contain only comments.</li>
        <li>Provide support for a wide variety of programming languages.</li>
        <li>Provide integration with a wide variety of IDEs/text editors.</li>
        <li>Load a document from source code, allow edits in a GUI, then save
            it back to source code.
            <ul>
                <li>Provide word processor GUI tools (insert hyperlink, images,
                    headings, change font, etc) for doc blocks.</li>
                <li>Provide text editor/IDE tools (syntax highlighting, line
                    numbers, show linter feedback) for code blocks.</li>
            </ul>
        </li>
        <li>Eliminate the traditional project build process -- make it almost
            instantaneous. Instead, on save, the system should update all
            affected files; any opened files should also be updated in the GUI.
        </li>
        <li>Doc block markup should be readable and well-known.</li>
        <li>Support either a single-file mode or a project mode.
            <ul>
                <li>A project is a specific directory tree, identified by the
                    presence of a TOC.&nbsp;I like&nbsp;<a
                        href="https://rust-lang.github.io/mdBook/format/summary.html">mdbook's
                        appearance</a>,</li>
                <li>A page in a project build is a single-file page plus:
                    <ul>
                        <li>A TOC, along with previous/next/up navigation. The
                            TOC is synchronized to the current page.</li>
                        <li>Numbering comes from the current page's location
                            within the TOC. Pages not in the TOC aren't
                            numbered.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a id="authoring-support"></a>Proivde authoring support for:
            <ul>
                <li>Auto-titled links: the link text is automatically derived
                    from the link's destination (the heading text at the link's
                    destination, for example).</li>
                <li>Bidirectional links</li>
                <li>Named anchors.</li>
            </ul>
        </li>
        <li>Allow picking files/anchors from a list in a GUI.</li>
    </ul>
    <h3>Nice to have features</h3>
    <ul>
        <li>Simple to install locally; support some sort of web-based IDE.
            Ideas: allow editing a GitHub repo directly.</li>
        <li>Support a static build: producing a set of view-only HTML files
            which don't need a server for a project, or a single HTML file
            outside a project.</li>
        <li>Keep an updated DAG of all links.
            <ul>
                <li>Warn of any orphans (unlinked pages), broken links.</li>
                <li>Provide the ablity to rename a file/directory and update
                    links in any referring files.</li>
                <li>Provide the ability to move link targets from one file to
                    another, updating links in any referring file.</li>
            </ul>
        </li>
    </ul>
    <h2>Implementation</h2>
    <ul>
        <li>Doc block markup thoughts:
            <ul>
                <li>For any markup, must either have:
                    <ul>
                        <li>Round-trip capable conversion: from x to HTML
                            (load), then from HTML back to x (save).</li>
                        <li>A GUI editor that works on this markup language. I
                            don't know of any (except for HTML).</li>
                    </ul>
                </li>
                <li>HTML is simple to implement (already done). However, it's
                    less readable.</li>
                <li>Markdown is very well known, dut to GitHub's use of it, and
                    is more readable (IMHO). It seems like a possible candidate
                    -- anything that can't be translated from HTML from
                    Markdown can simply be left as HTML, since Markdown allows
                    HTML as a part of its syntax. Markdown has a JavaScript
                    implementation for markdown to HTML. Pandoc can translate
                    HTML back to Markdown, but this requires installation of
                    another program and adds to the server-side complexity. The
                    <a
                        href="https://github.com/commonmark/commonmark.js/blob/master/lib/render/html.js">code</a>
                    that CommonMark uses to translate from their AST into HTML
                    looks pretty straightforward, so the inverse shouldn't be
                    too hard.</li>
            </ul>
        </li>
        <li>Picking anchors from a list implies the ability to look through
            docs blocks in a given source file and identify all links and
            anchors. Likewise, author support imples similar abilities. Does
            this happen on the server or the client?
            <ul>
                <li>Server: this seems the most obvious. This also makes a
                    static build easier to implement.</li>
                <li>The best tools for looking at the DOM are on the client.
                </li>
            </ul>
        </li>
        <li>TOC
            <ul>
                <li>While the TOC file must be placed in the root of the
                    project, it will be served alongside pages served from
                    subdirectories. What's the best approach? An iframe;
                    otherwise, need to rewrite all url (images, links, etc.)
                    which sounds hard.</li>
                <li>Implementation: have the TOC just be HTML. It should be
                    wrapped in a <a
                        href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav">&lt;nav&gt;
                        tag</a>. Require that numbered sections be expressed as
                    nested ordered lists, with links to each section inside
                    these lists.
                    <ul>
                        <li>Then,&nbsp;<code>document.querySelector('[href="https://example.com"]')</code>
                            finds the first instance of the current page's
                            link, which takes care of scrolling the TOC.</li>
                        <li>Given the a element in the TOC, looking through its
                            parents provides the section number. Given an array
                            of section numbers, use CSS to style all the
                            headings. One approach, which makes it easy for a
                            style sheet to include or exclude section numbers,
                            by making them CSS variables:<br>
                            <p><code>:root {</code><br><code>&nbsp;
                                    --section-counter-reset: s1 4 s2
                                    5;</code><br><code>&nbsp;
                                    --section-counter-content:
                                    counter(s1,
                                    numeric) '-' counter(s2,
                                    numeric);</code><br><code>}</code></p>
                            <p><code>h1::before
                                    {</code><br><code>&nbsp;
                                    counter-reset:
                                    var(--section-counter-reset);</code><br><code>&nbsp;
                                    content:
                                    var(--section-counter-content);</code><br><code>}</code>
                            </p>
                        </li>
                        <li>Side note: ideally, we'd ask the DOM for the
                            marker/number preceeding an ordered list item. JS
                            can find the index of each item in an ordered list,
                            but it won't get the actual marker used (Roman
                            numbers, bullets, or things generated by <a
                                href="https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type">list-style-type</a>).
                            There's a CSS&nbsp;<a
                                href="https://developer.mozilla.org/en-US/docs/Web/CSS/::marker">::marker</a>
                            selector, but not way to get the rendered text.
                            Even <a
                                href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText">innerText</a>
                            doesn't include the marker in the resulting text --
                            ack!</li>
                        <li>Plan:
                            <ol>
                                <li>Implement a project finder -- starting at
                                    the current directory, ascend to the root
                                    looking for the project file. If so, return
                                    a web page which includes the TOC as a
                                    sidebar plus some navigation (prev/next/up)
                                    placeholders. For prev/next, use
                                    this:<br><code>t =
                                        document.createTreeWalker(document.body,
                                        NodeFilter.SHOW_ELEMENT,
                                        {&nbsp;</code><br><code>&nbsp;
                                        acceptNode(node)
                                        {</code><br><code>&nbsp; &nbsp; return
                                        node.nodeName === "A" ?
                                        NodeFilter.FILTER_ACCEPT :
                                        NodeFilter.FILTER_SKIP;</code><br><code>&nbsp;
                                        }&nbsp;</code><br><code>});</code><br><code>t.currentNode
                                        = &lt;link corresponding to current
                                        page&gt;</code><br><code>next =
                                        t.nextNode();</code></li>
                                <li>Implement TOC scroll (on the client -- easy
                                    there). This means finding the first
                                    hyperlink to the current page. Given that,
                                    it's fairly easy to determine prev/next/up
                                    and section numbers. Implement all these.
                                </li>
                            </ol>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>Currently, creating multiple instances of the Ace editor is really
            slow, and starts a thread per editor. Find another approach.</li>
    </ul>
    <h3>Core development priorities</h3>
    <ol>
        <li>IDE integration</li>
        <li>Editor functionality</li>
        <li>Project support</li>
    </ol>
    <h3>Next steps</h3>
    <ol>
        <li>Set up a good development environment for JavaScript: use npm,
            TypeScript, a good unit-testing library, etc.</li>
        <li>Define the architecture for IDE extensions/plug-ins. Goal: minimize
            extension/plug-in complexity.</li>
        <li>Define desired UI behavior. Priority: auto-reload; dirty document
            detection; auto-backup.</li>
        <li>Implement Markdown support.</li>
        <li>Propose visual styling, dark mode, etc.</li>
    </ol>
    <h2>Open questions</h2>
    <ul>
        <li>How to enable affecting the <code>&lt;head&gt;</code> of a page? Of
            the entire project?</li>
        <li>Config file format: I really like and prefer Python's strictyaml.
            Basically, I want something that includes type validation and
            allows comments withing the config file. Perhaps JSON with a
            pre-parse step to discard comments then&nbsp;<a
                href="https://jsontypedef.com/">JSON Typedef</a>? Possibly,
            vlang can do this somewhat, since it wants to decode JSON into a V
            struct.)</li>
        <li>Config file contents: need to think through what belongs here. How
            to keep it as simple as possible? Perhaps provide a web-based GUI
            to make this easier to configure?</li>
        <li>How to specify the language for a doc block? Currently, we only
            support HTML. However, I'd like to support Markdown, and possibly
            also reST. Ideas: extensions, plus a default setting in a project
            file or the GUI; include a comment in the file.</li>
    </ul>
</div>
<h2>How to run</h2>
<div>The CodeChat repository's <a
        href="https://github.com/bjones1/CodeChat/tree/CodeChat-Editor/CodeChat">CodeChat-Editor
        branch</a> contains the code for this idea. To try it out:</div>
<div>
    <ol>
        <li><a
                href="https://github.com/vlang/v#installing-v---from-source-preferred-method">Install
                the V language</a>. On non-Windows systems, <a
                href="https://github.com/vlang/v#v-nethttp-netwebsocket-v-install">install
                OpenSSL libraries</a>.</li>
        <li><a href="https://github.com/vlang/v#symlinking">Symlink V</a>.</li>
        <li>In this directory, execute <code>v crun
                CodeChatEditorServer.v</code>.</li>
        <li>Open http://localhost:8080 in your browser.</li>
    </ol>
</div>
