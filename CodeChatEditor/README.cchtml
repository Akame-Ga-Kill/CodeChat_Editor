<h1>1. CodeChat Editor overview</h1>
<div>The CodeChat Editor should be a GUI-based programmer's word processor /
    Jupyter for software developers. This document records its overall design.
</div>
<div>&nbsp;</div>
<div>The heading are manually numbered; they will be automatically numbered.
</div>
<div>
    <h2><a id="how-to-run"></a>1.1 How to run</h2>
    <div>The CodeChat repository's <a
            href="https://github.com/bjones1/CodeChat/tree/CodeChat-Editor/CodeChat">CodeChat-Editor
            branch</a> contains the code for this idea. To try it out:</div>
    <div>
        <ol>
            <li><a
                    href="https://github.com/vlang/v#installing-v---from-source-preferred-method">Install
                    the V language</a>. On non-Windows systems, <a
                    href="https://github.com/vlang/v#v-nethttp-netwebsocket-v-install">install
                    OpenSSL libraries</a>.</li>
            <li><a href="https://github.com/vlang/v#symlinking">Symlink V</a>.
            </li>
            <li>In this directory, execute <code>v crun
                    CodeChatEditorServer.v</code>.</li>
            <li>Open http://localhost:8080 in your browser.</li>
        </ol>
    </div>
</div>
<h2><a id="vision"></a>1.2 Vision</h2>
<div>
    <ul>
        <li>View source code as <a
                id="vision-code-blocks-and-doc-blocks"></a><a
                href="index.cchtml#code-blocks-and-doc-blocks">code blocks and
                doc blocks</a>. Doc blocks are lines of source which contain
            only comments.</li>
        <li>Provide support for a <a
                id="vision-programming-language-support"></a><a
                href="index.cchtml#programming-language-support">wide variety
                of programming languages</a>.</li>
        <li>Provide integration with a <a id="vision-ide-integration"></a><a
                href="index.cchtml#ide-integration">wide variety of IDEs/text
                editors</a>.</li>
        <li>Load a document from source code, allow edits in a GUI, then save
            it back to source code.
            <ul>
                <li>Provide word processor GUI tools (insert hyperlink, images,
                    headings, change font, etc) for doc blocks.</li>
                <li>Provide text editor/IDE tools (syntax highlighting, line
                    numbers, show linter feedback) for code blocks.</li>
            </ul>
        </li>
        <li>Zero build: eliminate the traditional project build process -- make
            it almost instantaneous.</li>
        <li>Doc block markup should be readable and well-known.</li>
        <li>Support either a single-file mode or a project mode.
            <ul>
                <li>A project is a specific directory tree, identified by the
                    presence of a TOC.&nbsp;I like&nbsp;<a
                        href="https://rust-lang.github.io/mdBook/format/summary.html">mdbook's
                        appearance</a>,</li>
                <li>A page in a project build is a single-file page plus:
                    <ul>
                        <li>A TOC, along with previous/next/up navigation. The
                            TOC is synchronized to the current page.</li>
                        <li>Numbering comes from the current page's location
                            within the TOC. Pages not in the TOC aren't
                            numbered.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a id="authoring-support"></a>Provide <a
                href="index.cchtml#authoring-support">authoring support</a>
            for:
            <ul>
                <li>Auto-titled links: the link text is automatically derived
                    from the link's destination (the heading text at the link's
                    destination, for example).</li>
                <li>Bidirectional links. The source of a bidirectional link
                    must specify an anchor name, a target (file and anchor in
                    the file), the text to display at the target (typically,
                    the section which contains the source link), and where to
                    locate this text relative to the target anchor.</li>
                <li>Autogenerated anchor names.</li>
                <li>Autogenerated anchors for all headings.</li>
                <li>A page-local TOC.</li>
            </ul>
        </li>
        <li>Provide a GUI to make picking a file/anchor easy. Allow the user to
            click on an anchor in another file and copy/remember it, then
            paste/recall that anchor in the GUI?</li>
    </ul>
    <h3>Nice to have features</h3>
    <ul>
        <li>Simple to install locally; support some sort of web-based IDE.
            Ideas: allow editing a GitHub repo directly.</li>
        <li>Support a static build: producing a set of view-only HTML files
            which don't need a server for a project, or a single HTML file
            outside a project.</li>
        <li>Keep an updated DAG of all links.
            <ul>
                <li>Warn of any orphans (unlinked pages), broken links.</li>
                <li>Editing an anchor updates links in any referring files.
                </li>
                <li>Provide the ablity to rename a file/directory and update
                    links in any referring files.</li>
                <li>Provide the ability to move link targets from one file to
                    another, updating links in any referring file.</li>
            </ul>
        </li>
    </ul>
    <h2><a id="specification"></a>1.3 Specification</h2>
    <h3><a id="comment-classification"></a>Comment classification</h3>
    <p>Comments in most programming languages are either inline comments (which
        are terminated by a newline) or block comments, which may span multiple
        lines. In C/C++, the opening delimiter for an inline comment is
        <code>//</code>. Likewise, <code>/*</code> and <code>*/</code> define
        the opening and closing delimiters for block comments.</p>
    <h3><a id="specification-code-blocks-and-doc-blocks"></a>Code blocks and
        doc blocks</h3>
    <p>This design treats source code on a line-by-line basis. It does not
        classify at any deeper granularity -- for example, it does not support
        a mix of code block and doc block on the same line.</p>
    <p>A code block consists of all lines in a source file which aren't
        classified as a doc block. Note that code blocks may consist entirely
        of a comment, as illustrated below.</p>
    <p>A doc block consists of a comment (inline or block) optinally preceeded
        by whitespace and optionally succeeded by whitespace. At least one
        whitespace character must separate the opening comment delimiter from
        the doc block text. Some examples in C:</p>
    <pre>void foo(); // This is not a doc block, because these comments are preceeded<br>void bar(); // by non-whitespace characters. Instead, they're a code block.<br>//This is not a doc block, because these inline comments lack<br>//whitespace after the opening comment delimiter //. They're also a code block.<br>/*This is not a doc block, because this block comment lacks<br>  whitespace after the opening comment delimiter /*. It's also a code block. */<br>/* This is not a doc block, because non-whitespace <br>   characters follow the closing comment delimiter. <br>   It's also a code block. */ void food();<br><br>// This is a doc block. It has no whitespace preceeding the inline<br>// comment delimiers and one character of whitespace following it.<br>  // This is also a doc block. It has two characters of whitespace <br>  // preceeding the comment delimiters and one character of whitespace following it.<br>/* This is a doc block. Because it's based on<br>   a block comment, a single comment can span multiple lines. */<br>/* This is also a doc block, even without the visual alignment<br>or a whitespace before the closing comment delimiter.*/<br>  /* This is a doc block<br>     as well. */</pre>
    <p>&nbsp;Doc blocks are differentiated by their indent: the whitespace
        characters preceeding the opening comment delimiter. Adjacent doc
        blocks with identical indents are combined into a single, larger doc
        block.</p>
    <pre>// This is all one doc block, since only the preceeding<br>//   whitespace (there is none) matters, not the amount of <br>// whitespace following the opening comment delimiters.<br>  // This is the beginning of a different doc<br>  // block, since the indent is different.<br>    // Here's a third doc block; inline and block comments<br>    /* combine as long as the whitespace preceeding the comment<br>delimiters is identical. Whitespace inside the comment doesn't affect<br>       the classification. */<br>// These are two separate doc blocks,<br>void foo();<br>// since they are separated by a code block.</pre>
    <h3><a id="implementation-programming-language-support"></a><a
            href="index.cchtml#programming-language-support">Programming
            language support</a></h3>
    <p>Initial targets come from the Stack Overflow Developer Suvery 2022's
        section on <a
            href="https://survey.stackoverflow.co/2022/#section-most-popular-technologies-programming-scripting-and-markup-languages">programming,
            scripting, and markup languages</a> and IEEE Spectrum's <a
            href="https://spectrum.ieee.org/top-programming-languages-2022">Top
            Programming Languages 2022</a>.</p>
    <h3><a id="specification-ide-integration"></a>IDE/text editor integration
    </h3>
    <p>Initial targets come from the Stack Overflow Developer Suvery 2022's
        section on <a
            href="https://survey.stackoverflow.co/2022/#section-most-popular-technologies-integrated-development-environment">integrated
            development environments</a>.</p>
    <h3>Zero-build support</h3>
    <p>The "build" should occur when saving a file: push updates to any files
        that are currently being edited. Do lazy updates of closed files. Some
        examples:</p>
    <ul>
        <li>Editing the TOC then saving it should update the TOC in all open
            files. This seems relatively easy.</li>
        <li>Editing the text of a heading that's a target for an auto-titled
            link splits into two cases:
            <ul>
                <li>If the file is not being edited, then the auto-title link
                    text can be updated when the affected file is opened, as
                    part of the standard server-side processing on an open
                    file.</li>
                <li>If the file is being edited, then we need a way to update
                    just that text, which is a different code path. This is
                    more complicated, but still possible. The affected file may
                    also be the file just saved; in this case, we can just do
                    the standard server-wide processing when (re)opening the
                    file.</li>
            </ul>
        </li>
        <li>Moving/renaming an anchor that's the target of links in other files
            means:
            <ul>
                <li>The DAG must be fully updated, requiring a scan of all
                    files in the project. There could be edits made outside of
                    this environment that the cache doesn't know about; for the
                    rename to work, the cache must be current. Problem: if the
                    file is open and modified in a foreign editing environment,
                    changes there cannot be included in the DAG.</li>
                <li>A single edit can affect the link for multiple files. We
                    need some way to keep a list of pending edits to files.
                    This sounds complex.</li>
                <li>Perhaps have an option to update files in the background as
                    well as offer an "update now" button.</li>
            </ul>
        </li>
    </ul>
    <p>From a user perspective, define a save as a commit -- this is the moment
        when changes to this file should be reflected in other files when
        they're next opened. However, avoid writes to other files when the
        current file is saved. After all, the user saved the current file, not
        the other files; changes to other files at this time may be
        counterintuitive to the user and cause problems if these files are
        already open in another text editor/IDE not using this system.</p>
    <h3>Authoring support</h3>
    <p>This system should support custom tags to simplify the authoring
        process.</p>
    <h4>Auto-titled links</h4>
    <p>The link text is automatically derived from the link's destination (the
        heading text at the link's destination, for example). The text must not
        be editable in the GUI, since it will be overwritten when loading a
        page.</p>
    <h4>Bidirectional links</h4>
    <p>The source of a bidirection link must specify an anchor name, a target
        (file and anchor in the file), the text to display at the target
        (typically, the section which contains the source link), and where to
        locate this text relative to the target anchor.</p>
    <h4>Autogenerated anchor names and autogenerated anchors for all headings
    </h4>
    <p>The GUI should suggest an autogenerated name for anchors. This should
        probably be a random string, instead of taking existing text (a heading
        name) and sanitizing it. Otherwise, a heading's anchor name will be out
        of sync with the actual heading text as soon as the heading text is
        edited. BUT, this makes hyperlinks less comprehendable. If we keep a
        DAG of links, then renaming an anchor should be easy to propagate.</p>
    <p>To make headings easy to link to, all headings should receive
        autogenerated anchors. On hover, the headings should show a link
        symbol. Scrolling in the document to another heading should cause the
        TOC hilight to update.</p>
    <h4>Page-local TOC</h4>
    <p>A special tag (probably only for use in the TOC). Inputs: file to
        reference. Output: the hyperlinked title (&lt;h1&gt; tag's text) of the
        page, with nested lists for subheadings (with links to each
        subheading). Subpages of a page show up after headings on that page.
        The author may specify what depth of headings appear in the TOC on a
        global and per-page basis.</p>
    <h3>Hyperlink support</h3>
    <p>This system relies on the user to create a lot of meaningful links; it
        must make the creation and maintainence of links simple:</p>
    <ul>
        <li>Make it easy to create a link to another file/anchor via GUI
            support.
            <ul>
                <li>Provide a file browser-like dialog to select a file, then
                    an anchor inside that file. For files, show the title as
                    well as the file name; for anchors, show the surrounding
                    text.</li>
                <li>Allow the user to copy a link to any anchor, then paste
                    that into the GUI as another way of creating a link.</li>
            </ul>
        </li>
        <li>Clicking on an anchor should both browse to the page and also
            highlight the anchor's associated text.</li>
        <li>On hover, hyperlinks should show a preview of the linked web page.
        </li>
    </ul>
    <h2><a id="an-implementation"></a>1.4 Implementation</h2>
    <h3>Doc block markup</h3>
    <ul>
        <li>For any markup, must either have:
            <ul>
                <li>Round-trip capable conversion: from x to HTML (load), then
                    from HTML back to x (save).</li>
                <li>A GUI editor that works on this markup language. I don't
                    know of any (except for HTML).</li>
            </ul>
        </li>
        <li>HTML is simple to implement (already done). However, it's less
            readable.</li>
        <li>If we make Pandoc a depedency, then supporting a wide variety of
            markup languages is easy. However, any candidate language must be
            able to preserve arbitrary HTML, which may be problematic.</li>
        <li>Markdown is very well known, dut to GitHub's use of it, and is more
            readable (IMHO). It seems like a possible candidate -- anything
            that can't be translated from HTML from Markdown can simply be left
            as HTML, since Markdown allows HTML as a part of its syntax.
            Markdown has a JavaScript implementation for markdown to HTML.
            Pandoc can translate HTML back to Markdown, but this requires
            installation of another program and adds to the server-side
            complexity. The <a
                href="https://github.com/commonmark/commonmark.js/blob/master/lib/render/html.js">code</a>
            that CommonMark uses to translate from their AST into HTML looks
            pretty straightforward, so the inverse shouldn't be too hard.</li>
    </ul>
    <h3>Client/server partitioning</h3>
    <p>Picking anchors from a list implies the ability to look through docs
        blocks in a given source file and identify all links and anchors.
        Likewise, author support imples similar abilities. Does this happen on
        the server or the client?</p>
    <ul>
        <li>Server: this seems the most obvious. This also makes a static build
            easier to implement.</li>
        <li>The best tools for looking at the DOM are on the client.</li>
    </ul>
    <h3>Table of contents</h3>
    <ul>
        <li>While the TOC file must be placed in the root of the project, it
            will be served alongside pages served from subdirectories. What's
            the best approach? An iframe; otherwise, need to rewrite all url
            (images, links, etc.) which sounds hard.</li>
        <li>Implementation: have the TOC just be HTML. It should be wrapped in
            a <a
                href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav">&lt;nav&gt;
                tag</a>. Require that numbered sections be expressed as nested
            ordered lists, with links to each section inside these lists.
            <ul>
                <li>Then,&nbsp;<code>document.querySelector('[href="https://example.com"]')</code>
                    finds the first instance of the current page's link, which
                    takes care of scrolling the TOC.</li>
                <li>Given the a element in the TOC, looking through its parents
                    provides the section number. Given an array of section
                    numbers, use CSS to style all the headings. One approach,
                    which makes it easy for a style sheet to include or exclude
                    section numbers, by making them CSS variables:<br>
                    <p><code>:root {</code><br><code>&nbsp;
                            --section-counter-reset: s1 4 s2
                            5;</code><br><code>&nbsp;
                            --section-counter-content:
                            counter(s1,
                            numeric) '-' counter(s2,
                            numeric);</code><br><code>}</code></p>
                    <p><code>h1::before
                            {</code><br><code>&nbsp;
                            counter-reset:
                            var(--section-counter-reset);</code><br><code>&nbsp;
                            content:
                            var(--section-counter-content);</code><br><code>}</code>
                    </p>
                </li>
                <li>Side note: ideally, we'd ask the DOM for the marker/number
                    preceeding an ordered list item. JS can find the index of
                    each item in an ordered list, but it won't get the actual
                    marker used (Roman numbers, bullets, or things generated by
                    <a
                        href="https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type">list-style-type</a>).
                    There's a CSS&nbsp;<a
                        href="https://developer.mozilla.org/en-US/docs/Web/CSS/::marker">::marker</a>
                    selector, but not way to get the rendered text. Even <a
                        href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText">innerText</a>
                    doesn't include the marker in the resulting text -- ack!
                </li>
                <li>Plan:
                    <ol>
                        <li>Implement a project finder -- starting at the
                            current directory, ascend to the root looking for
                            the project file. If so, return a web page which
                            includes the TOC as a sidebar plus some navigation
                            (prev/next/up) placeholders. For prev/next, use
                            this:<br><code>t =
                                document.createTreeWalker(document.body,
                                NodeFilter.SHOW_ELEMENT,
                                {&nbsp;</code><br><code>&nbsp;
                                acceptNode(node)
                                {</code><br><code>&nbsp; &nbsp; return
                                node.nodeName === "A" ?
                                NodeFilter.FILTER_ACCEPT :
                                NodeFilter.FILTER_SKIP;</code><br><code>&nbsp;
                                }&nbsp;</code><br><code>});</code><br><code>t.currentNode
                                = &lt;link corresponding to current
                                page&gt;</code><br><code>next =
                                t.nextNode();</code></li>
                        <li>Implement TOC scroll (on the client -- easy there).
                            This means finding the first hyperlink to the
                            current page. Given that, it's fairly easy to
                            determine prev/next/up and section numbers.
                            Implement all these.</li>
                    </ol>
                </li>
            </ul>
        </li>
    </ul>
    <h3><a id="combined-code-document-editor"></a>Combined code/document editor
    </h3>
    <ul>
        <li>Currently, creating multiple instances of the Ace editor is really
            slow, and starts a thread per editor. Find another approach.</li>
    </ul>
    <h3>Cached state</h3>
    <p>As much as possible, avoid caching! Some items, though, would be
        expensive to dynamically determine. Design goal: minimize the amount of
        global state.</p>
    <p>The TOC is used in every served page, making it a good candidate for
        cached state. It needs:</p>
    <ul>
        <li>All headings in every file in the project (so that the
            autogenerated TOC for a file doesn't need to read and parse each
            file).</li>
        <li>The numbering determined by the TOC for every file in the project.
        </li>
    </ul>
    <p>The target of a bidirectional link needs to know all bidirectional link
        sources that reference it. Otherwise, we have to scan every file in the
        project to look for these links.</p>
    <p>Optional: keep a DAG of all links and anchors to enable:</p>
    <ul>
        <li>Orphan detection -- pages not reachable by links from the TOC.</li>
        <li>Broken links detection for internal links.</li>
        <li>Autoupdate all links when moving/renaming a file or anchor.</li>
    </ul>
    <h3>Settings</h3>
    <p>The settings should be configurable from a nice GUI. I like the VSCode
        idea -- make it easy to add more config values.</p>
    <ul>
        <li>Files/directories to process/ignore</li>
        <li>Header/footer info (name, version, copyright, etc.)</li>
        <li>The programming language and markup language for each source file.
        </li>
        <li>Text wrap width when saving.</li>
        <li>Visual styling (theme/style sheets, color, fonts, size of TOC
            sidebar, location of sidebar, etc.).</li>
        <li>Depth of headings to include in the page-local TOC.</li>
    </ul>
    <h3><a id="core-developmnt-priorities"></a>Core development priorities</h3>
    <ol>
        <li>IDE integration</li>
        <li>Editor functionality</li>
        <li>Project support</li>
    </ol>
    <h3><a id="next-steps"></a>Next steps</h3>
    <ol>
        <li>Set up a good development environment for JavaScript: use npm,
            TypeScript, a good unit-testing library, etc.</li>
        <li>Define the architecture for IDE extensions/plug-ins. Goal: minimize
            extension/plug-in complexity.</li>
        <li>Define desired UI behavior. Priority: auto-reload; dirty document
            detection; auto-backup.</li>
        <li>Implement Markdown support.</li>
        <li>Propose visual styling, dark mode, etc.</li>
    </ol>
    <h3>Open questions</h3>
    <ul>
        <li>How to enable affecting the <code>&lt;head&gt;</code> of a page? Of
            the entire project?</li>
        <li>Config file format: I really like and prefer Python's strictyaml.
            Basically, I want something that includes type validation and
            allows comments withing the config file. Perhaps JSON with a
            pre-parse step to discard comments then&nbsp;<a
                href="https://jsontypedef.com/">JSON Typedef</a>? Possibly,
            vlang can do this somewhat, since it wants to decode JSON into a V
            struct.)</li>
        <li>Config file contents: need to think through what belongs here. How
            to keep it as simple as possible? Perhaps provide a web-based GUI
            to make this easier to configure?</li>
        <li>How to specify the language for a doc block? Currently, we only
            support HTML. However, I'd like to support Markdown, and possibly
            also reST. Ideas: extensions, plus a default setting in a project
            file or the GUI; include a comment in the file.</li>
    </ul>
</div>
