<h1>1. CodeChat Editor overview</h1>
<div>The CodeChat Editor should be a GUI-based programmer's word processor /
    Jupyter for software developers. This document records its overall design.
</div>
<div>&nbsp;</div>
<div>These headings are manually numbered; they will be automatically numbered.
</div>
<div>
    <h2><a id="how-to-run"></a>1.1 How to run</h2>
    <div>The CodeChat repository's <a
            href="https://github.com/bjones1/CodeChat/tree/CodeChat-Editor/CodeChat">CodeChat-Editor
            branch</a> contains the code for this idea. To try it out:</div>
    <div>
        <ol>
            <li><a
                    href="https://github.com/vlang/v#installing-v---from-source-preferred-method">Install
                    the V language</a>. On non-Windows systems, <a
                    href="https://github.com/vlang/v#v-nethttp-netwebsocket-v-install">install
                    OpenSSL libraries</a>.</li>
            <li><a href="https://github.com/vlang/v#symlinking">Symlink V</a>.
            </li>
            <li>In this directory, execute <code>v crun
                    CodeChatEditorServer.v</code>.</li>
            <li>Open <code>http://localhost:8080</code> in your browser.</li>
            <li>Open the file <code>README.cchtml</code>.</li>
        </ol>
    </div>
</div>
<h2><a id="vision"></a>1.2 Vision</h2>
<p>These form a set of high-level requirements to guide the project.</p>
<div>
    <ul>
        <li>View source code as <a
                id="vision-code-blocks-and-doc-blocks"></a><a
                href="index.cchtml#code-blocks-and-doc-blocks">code blocks and
                doc blocks</a>. Doc blocks are lines of source which contain
            only correctly-formatted comments.</li>
        <li>Provide support for a <a
                id="vision-programming-language-support"></a><a
                href="index.cchtml#programming-language-support">wide variety
                of programming languages</a>.</li>
        <li>Provide integration with a <a id="vision-ide-integration"></a><a
                href="index.cchtml#ide-integration">wide variety of IDEs/text
                editors</a>.</li>
        <li>Load a document from source code, allow edits in a GUI, then save
            it back to source code.
            <ul>
                <li>Provide word processor GUI tools (insert hyperlink, images,
                    headings, change font, etc) for doc blocks.</li>
                <li>Provide text editor/IDE tools (syntax highlighting, line
                    numbers, show linter feedback) for code blocks.</li>
            </ul>
        </li>
        <li>Zero build: eliminate the traditional project build process -- make
            it almost instantaneous.</li>
        <li>Doc block markup should be readable and well-known.</li>
        <li>Support both a single-file mode and a project mode.
            <ul>
                <li>A project is a specific directory tree, identified by the
                    presence of a TOC.&nbsp;I like&nbsp;<a
                        href="https://rust-lang.github.io/mdBook/format/summary.html">mdbook's
                        appearance</a>,</li>
                <li>A page in a project build is a single-file page plus:
                    <ul>
                        <li>A TOC, along with previous/next/up navigation. The
                            TOC is synchronized to the current page.</li>
                        <li>Numbering comes from the current page's location
                            within the TOC. Pages not in the TOC aren't
                            numbered.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a id="authoring-support"></a>Provide <a
                href="index.cchtml#authoring-support">authoring support</a>,
            which allows authors to easily create book/project-like features.
            In particular:
            <ul>
                <li>Counters for numbering figures, tables, equations, etc.
                </li>
                <li>References (to a section, figure, table, etc.) via
                    auto-titled links: the link text is automatically derived
                    from the link's destination (the heading text at the link's
                    destination; a figure/table caption, etc.).</li>
                <li>Bidirectional links, which can be used for
                    footnotes/endnotes/citations and indices. The source of a
                    bidirectional link must specify an anchor name, a target
                    (file and anchor in the file), the text to display at the
                    target (typically, the section which contains the source
                    link), and where to locate this text relative to the target
                    anchor.</li>
                <li>A page-local TOC, in order to produce the overall TOC.</li>
                <li>Autogenerated anchor names and autogenerated anchors for
                    all headings.</li>
                <li>Hyperlinks to identifiers in code (use <a
                        href="https://github.com/universal-ctags/ctags">ctags</a>).
                    Perhaps autogenerated titles as well.</li>
                <li>Substitutions.</li>
                <li>Files/anchors can be freely moved without breaking links.
                </li>
            </ul>
        </li>
        <li>Provide a GUI to make picking a file/anchor easy.</li>
        <li>Provide edit, view, and view raw source options.</li>
    </ul>
    <h3>Nice to have features</h3>
    <ul>
        <li>Simple to install locally; support some sort of web-based IDE.
            Ideas: allow editing a GitHub repo directly.</li>
        <li>Support a static build: producing a set of view-only HTML files
            which don't need a server for a project, or a single HTML file
            outside a project.</li>
    </ul>
    <h2><a id="specification"></a>1.3 Requirements</h2>
    <p>The requirements expand on the vision by providing additional details.
    </p>
    <h3><a id="specification-code-blocks-and-doc-blocks"></a>Code blocks and
        doc blocks</h3>
    <p>Comments in most programming languages are either inline comments (which
        are terminated by a newline) or block comments, which may span multiple
        lines. In C/C++, the opening delimiter for an inline comment
        is&nbsp;<code>//</code>. Likewise, <code>/*</code> and <code>*/</code>
        define the opening and closing delimiters for block comments.</p>
    <p>This design treats source code on a line-by-line basis. It does not
        classify at any deeper granularity -- for example, it does not support
        a mix of code block and doc block on the same line.</p>
    <p>A code block consists of all lines in a source file which aren't
        classified as a doc block. Note that code blocks may consist entirely
        of a comment, as illustrated below.</p>
    <p>A doc block consists of a comment (inline or block) optionally preceded
        by whitespace and optionally succeeded by whitespace. At least one
        whitespace character must separate the opening comment delimiter from
        the doc block text. Some examples in C:</p>
    <pre>void foo(); // This is not a doc block, because these comments are preceded<br>void bar(); // by non-whitespace characters. Instead, they're a code block.<br>//This is not a doc block, because these inline comments lack<br>//whitespace after the opening comment delimiter //. They're also a code block.<br>/*This is not a doc block, because this block comment lacks<br>  whitespace after the opening comment delimiter /*. It's also a code block. */<br>/* This is not a doc block, because non-whitespace <br>   characters follow the closing comment delimiter. <br>   It's also a code block. */ void food();<br><br>// This is a doc block. It has no whitespace preceding the inline<br>// comment delimiters and one character of whitespace following it.<br>  // This is also a doc block. It has two characters of whitespace <br>  // preceding the comment delimiters and one character of whitespace following it.<br>/* This is a doc block. Because it's based on<br>   a block comment, a single comment can span multiple lines. */<br>/* This is also a doc block, even without the visual alignment<br>or a whitespace before the closing comment delimiter.*/<br>  /* This is a doc block<br>     as well. */</pre>
    <p>&nbsp;Doc blocks are differentiated by their indent: the whitespace
        characters preceding the opening comment delimiter. Adjacent doc blocks
        with identical indents are combined into a single, larger doc block.
    </p>
    <pre>// This is all one doc block, since only the preceding<br>//   whitespace (there is none) matters, not the amount of <br>// whitespace following the opening comment delimiters.<br>  // This is the beginning of a different doc<br>  // block, since the indent is different.<br>    // Here's a third doc block; inline and block comments<br>    /* combine as long as the whitespace preceeing the comment<br>delimiters is identical. Whitespace inside the comment doesn't affect<br>       the classification. */<br>// These are two separate doc blocks,<br>void foo();<br>// since they are separated by a code block.</pre>
    <h3><a id="implementation-programming-language-support"></a><a
            href="index.cchtml#programming-language-support">Programming
            language support</a></h3>
    <p>Initial targets come from the Stack Overflow Developer Survey 2022's
        section on&nbsp;<a
            href="https://survey.stackoverflow.co/2022/#section-most-popular-technologies-programming-scripting-and-markup-languages">programming,
            scripting, and markup languages</a> and IEEE Spectrum's <a
            href="https://spectrum.ieee.org/top-programming-languages-2022">Top
            Programming Languages 2022</a>.</p>
    <h3><a id="specification-ide-integration"></a>IDE/text editor integration
    </h3>
    <p>Initial targets come from the Stack Overflow Developer Survey 2022's
        section on&nbsp;<a
            href="https://survey.stackoverflow.co/2022/#section-most-popular-technologies-integrated-development-environment">integrated
            development environments</a>.</p>
    <h3>Zero-build support</h3>
    <p>The "build" should occur immediately (to any open files) or when when
        saving a file (to closed files, which will be updated when they're next
        opened). Exception: edits to the TOC are applied only after a save.</p>
    <h3>Authoring support</h3>
    <p>This system should support custom tags to simplify the authoring
        process. The GUI must indicate that text enclosed by the tags isn't
        directly editable, instead providing an option to edit the underlying
        tag that produced the text. When a new tag is inserted, any
        tag-produced content should be immediately added.</p>
    <h4>Counters</h4>
    <p>Counters are not global; they're local to a page. Instead, they take the
        prefix from the TOC value assigned to the preceding heading tag.</p>
    <h4>References (auto-titled links)</h4>
    <p>The link text is automatically derived from the link's destination (the
        heading text at the link's destination, for example). The text must not
        be editable in the GUI, since it will be overwritten by updates to the
        linked text.</p>
    <h4>Bidirectional links</h4>
    <p>The source of a bidirectional link must specify:</p>
    <ul>
        <li>An anchor name</li>
        <li>A target (the globally-unique anchor)</li>
        <li>The text to display at the target (typically, the section which
            contains the source link).</li>
        <li>Where to locate this text relative to the target anchor.</li>
    </ul>
    <p>To create a footnote/endnote/citation, pick a place in the document (end
        of section / bottom of page / bibliography) then type the text in.
        Next, create a bidirectional link to the place to insert the
        footnote/endnote/citation. The text of the link should come from the
        footnote/endnote/bibliography number just created.</p>
    <h4>Autogenerated anchor names and autogenerated anchors for all headings
    </h4>
    <p>The GUI should suggest an autogenerated name for anchors. This is a
        string of random characters; HTML allows upper/lowercase ASCII plus the
        hypen and underscore for IDs, meaning that a 5-character string
        provides &gt;250 million unique anchors.</p>
    <p>To make headings easy to link to, all headings should receive
        autogenerated anchors. On hover, the headings should show a link
        symbol. Scrolling in the document to another heading should cause the
        TOC hilight to update.</p>
    <h4>Page-local TOC</h4>
    <p>A special tag (probably only for use in the TOC). Inputs: file to
        reference. Output: the hyperlinked title (<code>&lt;h1&gt;</code> tag's
        text) of the page, with nested lists for subheadings (with links to
        each subheading). Subpages of a page show up after headings on that
        page. The author may specify what depth of headings appear in the TOC
        on a global and per-page basis.</p>
    <h4>Movable files/anchors</h4>
    <p>To make moving files/anchors (or anything an anchor is attached to --
        headings, figures, etc.) easy, require that all anchor be unique across
        the entire project, instead of unique just in the current file. Then,
        internal links can be reduced to the anchor; during hydration, the path
        to the file containing that anchor) is fetched from the cache. Place an
        anchor at the top of every file to uniquely identify it, and change
        links to a file to instead refer to this anchor.</p>
    <p>How to handle the case where an anchor isn't found in the cache? We'd
        then need to update the cache for the entire project, which might be
        expensive but also rare. Perhaps perform this update in the
        background.&nbsp;</p>
    <h3>Hyperlink support</h3>
    <p>This system relies on the user to create a lot of meaningful links; it
        must make the creation and maintainance of links simple:</p>
    <ul>
        <li>Make it easy to create a link to another file/anchor via GUI
            support.
            <ul>
                <li>Provide a file browser-like dialog to select a file, then
                    an anchor inside that file. For files, show the title as
                    well as the file name; for anchors, show the surrounding
                    text. Provide an isearch to make searching easier.</li>
                <li>Allow the user to copy a link to any anchor, then paste
                    that into the GUI as another way of creating a link.</li>
            </ul>
        </li>
        <li>Clicking on an anchor should both browse to the page and also
            highlight the anchor's associated text.</li>
        <li>On hover, hyperlinks should show a preview of the linked web page.
        </li>
    </ul>
    <h2><a id="an-implementation"></a>1.4 Implementation</h2>
    <h3>Doc block markup</h3>
    <ul>
        <li>For any markup, must either have:
            <ul>
                <li>Round-trip capable conversion: from x to HTML (load), then
                    from HTML back to x (save).</li>
                <li>A GUI editor that works on this markup language. I don't
                    know of any (except for HTML).</li>
            </ul>
        </li>
        <li>HTML is simple to implement (already done). However, it's less
            readable.</li>
        <li>If we make Pandoc a depedency, then supporting a wide variety of
            markup languages is easy. However, any candidate language must be
            able to preserve arbitrary HTML, which may be problematic.</li>
        <li>Markdown is very well known, dut to GitHub's use of it, and is more
            readable (IMHO). It seems like a possible candidate -- anything
            that can't be translated from HTML from Markdown can simply be left
            as HTML, since Markdown allows HTML as a part of its syntax.
            Markdown has a JavaScript implementation for markdown to HTML.
            Pandoc can translate HTML back to Markdown, but this requires
            installation of another program and adds to the server-side
            complexity. The <a
                href="https://github.com/commonmark/commonmark.js/blob/master/lib/render/html.js">code</a>
            that CommonMark uses to translate from their AST into HTML looks
            pretty straightforward, so the inverse shouldn't be too hard.</li>
    </ul>
    <h3>Client/server partitioning</h3>
    <p>Picking anchors from a list implies the ability to look through docs
        blocks in a given source file and identify all links and anchors.
        Likewise, author support imples similar abilities. Does this happen on
        the server or the client?</p>
    <ul>
        <li>Server: all the necessary data is on the server, and is usually not
            available on the client. This also makes a static build easier to
            implement.</li>
        <li>When an author support tag is added, it must be immediately
            populated. This requires the client to request this from the
            server. The obvious solution is to handle all tags on the client
            through a series of server-side requests.</li>
    </ul>
    <p>Solution: on the server, provide a function that processes a string of
        HTML containing author tags into plain HTML. The server can process the
        entire file, or just a snippet (a newly-inserted tag) sent by the
        client.</p>
    <p>One implementation approach: use XSLT. While this sounds interesting,
        the transformations require code behind them (an auto-title tag
        requires reading the referenced file to get the title, etc.); this
        doesn't seem to fit well with XSLT. In addition, XSLT operates on XML,
        so it requires transforming HTML into XHTML first. The V <a
            href="https://modules.vlang.io/net.html.html">net.html</a> library
        seems to be sufficient for this task.</p>
    <h3>Table of contents</h3>
    <ul>
        <li>While the TOC file must be placed in the root of the project, it
            will be served alongside pages served from subdirectories. What's
            the best approach? An iframe; otherwise, need to rewrite all url
            (images, links, etc.) which sounds hard.</li>
        <li>Implementation: have the TOC just be HTML. Require that numbered
            sections be expressed as nested ordered lists, with links to each
            section inside these lists.
            <ul>
                <li>Then,&nbsp;<code>document.querySelector('[href="https://example.com"]')</code>
                    finds the first instance of the current page's link, which
                    takes care of scrolling the TOC.</li>
                <li>Given the a element in the TOC, looking through its parents
                    provides the section number. Given an array of section
                    numbers, use CSS to style all the headings. One approach,
                    which makes it easy for a style sheet to include or exclude
                    section numbers, by making them CSS variables:<br>
                    <p><code>:root {</code><br><code>&nbsp;
                            --section-counter-reset: s1 4 s2
                            5;</code><br><code>&nbsp;
                            --section-counter-content:
                            counter(s1,
                            numeric) '-' counter(s2,
                            numeric);</code><br><code>}</code></p>
                    <p><code>h1::before
                            {</code><br><code>&nbsp;
                            counter-reset:
                            var(--section-counter-reset);</code><br><code>&nbsp;
                            content:
                            var(--section-counter-content);</code><br><code>}</code>
                    </p>
                </li>
                <li>Side note: ideally, we'd ask the DOM for the marker/number
                    preceding an ordered list item. JS can find the index of
                    each item in an ordered list, but it won't get the actual
                    marker used (Roman numbers, bullets, or things generated by
                    <a
                        href="https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type">list-style-type</a>).
                    There's a CSS&nbsp;<a
                        href="https://developer.mozilla.org/en-US/docs/Web/CSS/::marker">::marker</a>
                    selector, but not way to get the rendered text. Even <a
                        href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText">innerText</a>
                    doesn't include the marker in the resulting text -- ack!
                </li>
                <li>Plan:
                    <ol>
                        <li>Implement a project finder -- starting at the
                            current directory, ascend to the root looking for
                            the project file. If so, return a web page which
                            includes the TOC as a sidebar plus some navigation
                            (prev/next/up) placeholders. For prev/next, use
                            this:<br><code>t =
                                document.createTreeWalker(document.body,
                                NodeFilter.SHOW_ELEMENT,
                                {&nbsp;</code><br><code>&nbsp;
                                acceptNode(node)
                                {</code><br><code>&nbsp; &nbsp; return
                                node.nodeName === "A" ?
                                NodeFilter.FILTER_ACCEPT :
                                NodeFilter.FILTER_SKIP;</code><br><code>&nbsp;
                                }&nbsp;</code><br><code>});</code><br><code>t.currentNode
                                = &lt;link corresponding to current
                                page&gt;</code><br><code>next =
                                t.nextNode();</code></li>
                        <li>Implement TOC scroll (on the client -- easy there).
                            This means finding the first hyperlink to the
                            current page. Given that, it's fairly easy to
                            determine prev/next/up and section numbers.
                            Implement all these.</li>
                    </ol>
                </li>
            </ul>
        </li>
    </ul>
    <h3><a id="combined-code-document-editor"></a>Combined code/document editor
    </h3>
    <ul>
        <li>Currently, creating multiple instances of the Ace editor is really
            slow, and starts a thread per editor. Find another approach.</li>
        <li>Need to pass the Ace parser start from the end of one instance to
            the beginning of the next. Need to keep line numbers updated after
            edits as well.</li>
    </ul>
    <h3>Cached state</h3>
    <p>When hydrating a page (transforming all custom tags into standard HTML)
        on the server, all needed hydration data should be stored in the cache.
    </p>
    <p>A list of all links and anchors enables:</p>
    <ul>
        <li>Orphan detection -- pages not reachable by links from the TOC.</li>
        <li>Broken link detection for internal links.</li>
    </ul>
    <h4>Data and format</h4>
    <ul>
        <li>For each file (including anything linkable -- images, videos,
            etc.), stored as the relative path from the project's root
            directory to that file:
            <ul>
                <li>A time/date stamp to determine if this cached data is stale
                    or not.</li>
                <li>The global TOC numbering.</li>
                <li>A list of anchors, including the no-anchor case (a
                    reference to the file with no anchor). For each anchor:
                    <ul>
                        <li>The outer HTML of its next sibling, for use with
                            references.</li>
                        <li>Its numbering withing the current page, also for
                            use with references.&nbsp;</li>
                        <li>A list of referring links. For each link, include:
                            <ul>
                                <li>The outer HTML of its next sibling, for use
                                    with bidirectional links.</li>
                                <li>Its numbering within the current page, also
                                    for use with bidirectional links.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>A subset of the previous list, containing only headings.
                    Note: some headings may not have anchors yet!</li>
            </ul>
        </li>
    </ul>
    <h4>Editing and cached state</h4>
    <p>Edits to the document of any cached items cause the browser to push this
        edit to the server; the server then propagates the edits to open
        windows and updates its state. If a modified file is closed without
        saving it (meaning the cached state for this file is now invalid), then
        all that cache state must be flushed. To flush, simply set the
        date/time stamp of that file to something old/invalid.</p>
    <h3>TOC</h3>
    <p>Options:</p>
    <ul>
        <li>Path to linked file</li>
        <li>Depth of numbering</li>
    </ul>
    <h4>Example</h4>
    <div class="CodeChat-toc mceNonEditable"
        data-codechat-path="static/css/CodeChatEditor.css"
        data-codechat-depth="">
        <p>asdf</p>
    </div>
    <h3>Numbering</h3>
    <p>On a page, the local TOC numbering comes only from heading tags. The CSS
        (which would adding numbering to selected headings) must be kept in
        sync with the code which infers the numbering. A simple value (4,
        meaning h1-h4 are numbered) is all the code needs. How to do this?</p>
    <p>On the TOC, numbering may come from both heading tags and ordered lists,
        again based on the CSS. Numbered headings should be included in the
        numbering, followed by ordered list numbering.&nbsp;</p>
    <h3>Settings</h3>
    <p>The settings should be configurable from a nice GUI. I like the VSCode
        idea -- make it easy to add more config values.</p>
    <ul>
        <li>Files/directories to process/ignore</li>
        <li>Header/footer info (name, version, copyright, etc.)</li>
        <li>The programming language, markup language, and spellchecker
            language for each source file.</li>
        <li>Text wrap width when saving.</li>
        <li>Visual styling (theme/style sheets, color, fonts, size of TOC
            sidebar, location of sidebar, etc.).</li>
        <li>HTML <code>&lt;head&gt;</code> modifications: CSS/JS to add to all
            pages/a set of pages.</li>
        <li>Depth of headings to include in the page-local TOC.</li>
        <li>Auto-reload if modified externally or not</li>
        <li>Tabs vs spaces; newline type</li>
        <li>Substitutions</li>
    </ul>
    <h3><a id="core-developmnt-priorities"></a>Core development priorities</h3>
    <ol>
        <li>IDE integration</li>
        <li>Editor functionality</li>
        <li>Project support</li>
    </ol>
    <h3><a id="next-steps"></a>Next steps</h3>
    <ol>
        <li>Set up a good development environment for JavaScript: use npm,
            TypeScript, a good unit-testing library, etc.</li>
        <li>Define the architecture for IDE extensions/plug-ins. Goal: minimize
            extension/plug-in complexity.</li>
        <li>Define desired UI behavior. Priority: auto-reload; dirty document
            detection; auto-backup.</li>
        <li>Implement Markdown support.</li>
        <li>Propose visual styling, dark mode, etc.</li>
    </ol>
    <h3>To do</h3>
    <ol>
        <li>Improve accessibility -- use a <code>&lt;main&gt;</code> tag,
            <code>&lt;nav&gt;</code> tags, etc.</li>
        <li>Get a page's title from its <code>&lt;h1&gt;</code> tag.</li>
        <li>Open the TOC as a single-file edit? If not, at least hide the
            sidebar, since that's redundant.</li>
    </ol>
    <h3>Open questions</h3>
    <ul>
        <li>I'd like to be able to wrap a heading and associated content in a
            <code>&lt;section&gt;</code> tag. This is hard to do -- if a
            heading appears in the middle of an indented comment, then need
            special processing (close the section, then the indent, then
            restart a new indent and section). In addition, it requires that
            code is nested inside doc blocks, which is tricky. However, I would
            like to do this.</li>
        <li>How to handle images/videos/PDFs/etc. when file are moved?
            Currently, we expect the user to move them as well. There's not an
            easy way to tag them with an unique ID, then refer to them using
            that ID than I can think of.</li>
        <li>Config file format: I really like and prefer Python's strictyaml.
            Basically, I want something that includes type validation and
            allows comments within the config file. Perhaps JSON with a
            pre-parse step to discard comments then <a
                href="https://jsontypedef.com/">JSON Typedef</a>? Possibly,
            vlang can do this somewhat, since it wants to decode JSON into a V
            struct.)</li>
    </ul>
    <h2>1.5 Organization</h2>
    <h3>Client</h3>
    <ul>
        <li>Written in TypeScript</li>
        <li>npm for library management</li>
        <li>webpack</li>
    </ul>
    <h3>Server</h3>
    <ul>
        <li>Written in vlang</li>
    </ul>
    <h3>Plugins/extensions</h3>
    <ul>
        <li>Language determined by host environment</li>
    </ul>
    <h3>Communication</h3>
    <ul>
        <li>Use http for client web page loading. Provide /fs path for
            filesystem access.</li>
        <li>Use websockets for client/server connection.</li>
        <li>Use http for plugin/server connection. Websockets would be better,
            but not sure how supported this is.</li>
    </ul>
    <h2>License</h2>
    <p>This file is part of the CodeChat Editor.</p>
    <p>The CodeChat Editor is free software: you can redistribute it and/or
        modify it under the terms of the GNU General Public License as
        published by the Free Software Foundation, either version 3 of the
        License, or (at your option) any later version.</p>
    <p>The CodeChat Editor is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
        General Public License for more details.</p>
    <p>You should have received a <a href="LICENSE.html">copy</a> of the GNU
        General Public License along with the CodeChat Editor. If not, see <a
            href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.
    </p>
</div>
